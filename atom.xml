<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yh0214.github.io</id>
    <title>yanghang</title>
    <updated>2019-11-06T01:38:22.552Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yh0214.github.io"/>
    <link rel="self" href="https://yh0214.github.io/atom.xml"/>
    <logo>https://yh0214.github.io/images/avatar.png</logo>
    <icon>https://yh0214.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, yanghang</rights>
    <entry>
        <title type="html"><![CDATA[类的方法&变量]]></title>
        <id>https://yh0214.github.io/post/lei-de-fang-fa-andbian-liang</id>
        <link href="https://yh0214.github.io/post/lei-de-fang-fa-andbian-liang">
        </link>
        <updated>2019-10-30T03:07:07.000Z</updated>
        <content type="html"><![CDATA[<pre><code>class Mobile:
    has_logo = True
    has_ram = True

    def __init__(self,model,brand):
        # 把参数转化成实例变量
        self.mobile_model = model
        self.brand = brand

    def capture(self):
        # 实例方法中使用类变量
        print(self.has_logo)
        print(&quot;{}正在照相&quot;.format(self.brand))

    def beautify_cap(self):
        self.capture()
        print(&quot;修照片&quot;)

    @classmethod
    def if_logo(cls):
        # 类方法
        # 类方法很少使用
        print(cls.has_logo)

    @staticmethod
    def check_weather():
        print(&quot;今天天气......&quot;)
</code></pre>
<p>对象的实例化</p>
<pre><code>iphone5 = Mobile('5', '苹果')
</code></pre>
<p>怎么去使用类的变量 类的变量包含类变量和实例变量</p>
<pre><code>print(iphone5.mobile_model)
print(iphone5.brand)
</code></pre>
<p>类外面使用类变量</p>
<pre><code>print(Mobile.has_logo)
print(iphone5.has_logo)
</code></pre>
<p>对象调用实例方法<br>
iphone5.capture()</p>
<p>类变量和实例变量有什么区别？<br>
类变量能同时被类和实例访问，实例变量只能被实例自己访问</p>
<p>实例属性放在__init__中定义，self.相关的属性优先放在__init__中定义</p>
<p>静态方法和这个类以及对象没有关系，但是有关联<br>
静态方法和普通函数相比，好处是方便管理<br>
例子</p>
<pre><code>class InterViewer:

    def __init__(self, name):
        self.name = name

    def offer(self, money, time):
        print(&quot;{} 收了一个大 offer：月薪{},k {}天到岗&quot;.format(self.name, money, time))
        return '拿 offer'

    def eat(self, food):
        print(&quot;{} 最喜欢吃 {}&quot;.format(self.name, food))

    def interviwing(self):
        print(&quot;正在面试&quot;)


cainiao = InterViewer('菜鸟')
print(cainiao.offer(50, 1))
cainiao.interviwing()
</code></pre>
<pre><code>class FileHandler:
    def __init__(self,filename,encoding='utf-8'):
        self.filename = filename
        self.encoding = encoding

    def read_file(self):
        with open(self.filename, mode='r', encoding=self.encoding) as f:
            a = f.read()
        return a

    def write_file(self, data,mode='w'):
        with open(self.filename, mode=mode, encoding=self.encoding) as f:
            f.write(data)


handler = FileHandler('demo.txt')
print(handler.read_file())

handler.write_file('147258369',mode='a')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类的创建&调用]]></title>
        <id>https://yh0214.github.io/post/lei-de-chuang-jian-anddiao-yong</id>
        <link href="https://yh0214.github.io/post/lei-de-chuang-jian-anddiao-yong">
        </link>
        <updated>2019-10-30T00:48:14.000Z</updated>
        <content type="html"><![CDATA[<p>类，一群有共同的特征和行为的事物<br>
类名，标识符，大驼峰命名法<br>
类的表示方法</p>
<pre><code>class DaLao:
    pass
</code></pre>
<p>特征又被称为属性，类属性，类成员都具备的共同点。<br>
特征由变量表示，变量写在类下面</p>
<pre><code>class DaLao:
    haird = &quot;low&quot;
    eyed = &quot;class&quot;
    fav_shoes = &quot;tuo shoes&quot;


print(DaLao.haird)
print(DaLao.eyed)
</code></pre>
<p>对象：某个类下面具体的一个个体<br>
在类里面定义的函数称为方法<br>
初始化方法也叫构造函数 只能返回None<br>
初始化对象的时候自动调用__init__方法<br>
实例 = 对象<br>
类变量 = 类属性<br>
实例变量 = 实例属性<br>
实例变量是表示某一个对象拥有的特征</p>
<pre><code>class SingleDog:
    freedom = True
    favor = &quot;吃狗粮&quot;
    sports_hobby = &quot;睡觉&quot;

    def __init__(self,name,favor_game):
        self.name = name
        self.favor_game = favor_game
        print('hello')


single_dog = SingleDog('huhu','abc')
print(single_dog)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路径处理&文件读写&异常处理]]></title>
        <id>https://yh0214.github.io/post/osandwen-jian-cao-zuo-andyi-chang-chu-li</id>
        <link href="https://yh0214.github.io/post/osandwen-jian-cao-zuo-andyi-chang-chu-li">
        </link>
        <updated>2019-10-29T07:07:46.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>路径处理<pre><code>import os
</code></pre>
</li>
<li>获取当前工作的文件夹路径，此路径是指在哪里运行python文件，此方法不经常使用<pre><code>print(os.getcwd())
</code></pre>
</li>
<li>文件的绝对路径，非常有用</li>
</ul>
<pre><code> print(os.path.abspath(__file__))
</code></pre>
<ul>
<li>
<p>获取文件路径的文件夹路径</p>
<pre><code>dir_name = os.path.dirname(os.path.abspath(__file__))
</code></pre>
</li>
<li>
<p>路径拼接</p>
<pre><code>new_dir = os.path.join(dir_name,'data')
</code></pre>
</li>
<li>
<p>创建文件夹，使用该方法创建要一层一层创建，否则会报错</p>
<pre><code>os.mkdir(new_dir)
</code></pre>
</li>
<li>
<p>首先判断文件夹是否存在，存在则再去创建</p>
<pre><code>new_dir = os.path.join(dir_name,'data','cases')
new_dir_data = os.path.dirname(new_dir)
if os.path.exists(new_dir_data):
    os.mkdir(new_dir)
else:
    print('data文件夹不存在')
</code></pre>
</li>
<li>
<p>判断是否是一个文件夹，返回True或者False</p>
<pre><code>print(os.path.isdir(new_dir))
</code></pre>
</li>
<li>
<p>判断是否是一个文件，返回True或者False</p>
<pre><code>print(os.path.isfile(new_dir))
</code></pre>
</li>
<li>
<p>打开文件 文件内容有汉字时使用utf-8打开</p>
<pre><code>f = open('demo.txt',encoding='utf-8')
</code></pre>
</li>
<li>
<p>读文件</p>
<pre><code>print(f.read())
</code></pre>
</li>
<li>
<p>一行一行读取文件</p>
<pre><code>f = open('demo.txt',encoding='utf-8')
print(f.readlines())
</code></pre>
</li>
<li>
<p>写文件 mode为'w'，如果文件已经存在，写入内容的时候，原来的文件内容会被覆盖</p>
</li>
<li>
<p>如果不想被覆盖，mode应该使用'a'</p>
</li>
<li>
<p>mode为'x'，创作模式，文件已经存在时使用x模式会报错</p>
<pre><code>f = open('demo.txt',mode='w',encoding='utf-8')
f.write('呼呼，哈哈')
</code></pre>
</li>
<li>
<p>关闭文件，当打开文件执行了操作后，一定要记得关闭</p>
<pre><code>f.close()
</code></pre>
</li>
<li>
<p>防止忘记关闭文件</p>
<pre><code>with open('demo.txt',mode='r',encoding='utf-8') as f:
  print(f.read())
</code></pre>
</li>
<li>
<p>异常处理<br>
try:<br>
执行代码<br>
except 错误类型1：<br>
pass<br>
except 错误类型2：<br>
pass<br>
except (错误类型3,错误类型4):<br>
pass</p>
</li>
</ul>
<pre><code>try:
    1/0
    mylist = [1, 2, 3, 4, 5, 6]
    mylist[100]
except IndexError:
    print('wrong2')
except ZeroDivisionError:
    print('wrong')
</code></pre>
<ul>
<li>try：遇到错误代码就会终止分支，只会执行except ZeroDivisionError分支</li>
<li>异常处理写except Exception，不写具体错误类型，会不好定位问题<br>
为什么进行异常处理？<br>
为了让程序按我们的想法执行。<br>
手动抛出异常 raise</li>
</ul>
<pre><code>class MyError(Exception):
    pass


try:
    mylist = [1, 2, 3]
    mylist[4]
    1 / 0
except (ZeroDivisionError, IndexError) as e:
    raise MyError
</code></pre>
<p>finally</p>
<pre><code>try:
    mylist = [1, 2, 3]
    mylist[4]
    1 / 0
except (ZeroDivisionError, IndexError) as e:
    print('error')
finally:
    print('douhuiyuxning')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[包和模块]]></title>
        <id>https://yh0214.github.io/post/os</id>
        <link href="https://yh0214.github.io/post/os">
        </link>
        <updated>2019-10-21T01:21:51.000Z</updated>
        <content type="html"><![CDATA[<p>模块是Python程序架构的一个核心概念<br>
以py为后缀名的文件就是模块，含有__init__.py的目录叫做包<br>
智能导入：alt + enter<br>
导入方式：<br>
1、import + 模块名，使用这种方式调用函数时必须用import后面的所有部分.函数来调用<br>
2、import + 模块名 as 别名<br>
3、from 包.模块名 import 函数名<br>
4、from 包 import 模块名<br>
5、from 包 import 模块名 as 别名<br>
6、from ... import * 引入所有的方法，尽量不使用此方法<br>
别名的使用场景：<br>
1、名字比较长 2、导入的名字和在这个文件当中存在同名的情况<br>
包 --&gt; 模块 --&gt; 函数（类），变量<br>
包是表示存储python代码的文件夹，在以前的python版本中package中有__init__.py才被认为是包，在新版本的python中package中没有__init__.py也被认为是包<br>
模块的搜索顺序<br>
在导入模块时：</p>
<ul>
<li>搜索当前目录指定模块的文件，如果有就直接导入</li>
<li>如果没有，再搜索系统目录</li>
<li>将某个路径添加到系统系统下：sys.path.append('C:\class_09_modules')</li>
<li>每一个模块都有一个内置属性__file__ 可以查看模块的完整路径<br>
__name__属性</li>
<li>测试模块的代码只在测试情况下被运行，而在导入时不会被执行</li>
<li>__name__是一个内置属性</li>
<li>如果被其他文件导入的，__name__就是模块名</li>
<li>如果是当前执行的程序，<strong>name__是__main</strong></li>
</ul>
<p><strong>main__是程序入口，运行的哪一个文件，那么那一个文件就叫__main</strong><br>
if <strong>name</strong> == '<strong>main</strong>':  用来测试模块</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象基础]]></title>
        <id>https://yh0214.github.io/post/mian-xiang-dui-xiang-ji-chu</id>
        <link href="https://yh0214.github.io/post/mian-xiang-dui-xiang-ji-chu">
        </link>
        <updated>2019-10-16T01:07:30.000Z</updated>
        <content type="html"><![CDATA[<p>面向对象（OOP）是一种编程范式<br>
范式可以认为是一组方法论<br>
编程范式就是一组如何组织代码的方法论<br>
OOP的世界观：<br>
世界是由对象组成的<br>
对象具有运动规律和内部状态<br>
对象之间可以相互作用<br>
OOP的特征：<br>
封装<br>
继承<br>
多态<br>
类的定义</p>
<pre><code>class Door:
    def __init__(self,number,status):
        self.number = number
        self.status = status

door = Door(10001,'closed')
</code></pre>
<pre><code>In[]：door.number
Out[]：10001
</code></pre>
<p>看一下self</p>
<pre><code>class D:
    def __init__(self):
        print(id(self))
</code></pre>
<pre><code>In[]：d = D()
Out[]：101570264
</code></pre>
<pre><code>In[]：id(d)
Out[]：101570264
</code></pre>
<p>这个self就是d，而且是先有的self<br>
__init__函数并不是来生成对象的，只是来初始化类<br>
类中定义方法及调用</p>
<pre><code>class Door:
    def __init__(self,number,status):
        self.number = number
        self.status = status
    
    def open(self):
        self.status = &quot;opening&quot;

    def close(self):
        self.status = &quot;closed&quot;
</code></pre>
<pre><code>door = Door(10001,'closed')
</code></pre>
<pre><code>In[]：door.status
Out[]：'closed'
</code></pre>
<pre><code>door.open()
</code></pre>
<pre><code>In[]：door.status
Out[]：'opening'
</code></pre>
<pre><code>door.close()
</code></pre>
<pre><code>In[]：door.status
Out[]：'closed'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[带参数的装饰器]]></title>
        <id>https://yh0214.github.io/post/dai-can-shu-de-zhuang-shi-qi</id>
        <link href="https://yh0214.github.io/post/dai-can-shu-de-zhuang-shi-qi">
        </link>
        <updated>2019-10-12T05:57:56.000Z</updated>
        <content type="html"><![CDATA[<p>首先看一下装饰器的副作用</p>
<pre><code>import datetime
def logger(fn):
    def wrap(*args,**kwargs):
        start = datetime.datetime.now()
        ret = fn(*args,**kwargs)
        end = datetime.datetime.now()
        print('{} called took {}'.format(fn.__name__,end-start))
        return ret
    return wrap
</code></pre>
<pre><code>import time
@logger
def sleep(x):
    time.sleep(x)
</code></pre>
<p>使用装饰器定义一个sleep函数，查看它的'<strong>name</strong>'</p>
<pre><code>In[]:sleep.__name__
Out[]:'wrap'
</code></pre>
<p>是wrap而不是sleep，这就是使用了装饰器后的副作用<br>
如何解决？<br>
首先可以使用赋值</p>
<pre><code>import datetime
def logger(fn):
    def wrap(*args,**kwargs):
        start = datetime.datetime.now()
        ret = fn(*args,**kwargs)
        end = datetime.datetime.now()
        print('{} called took {}'.format(fn.__name__,end-start))
        return ret
    wrap.__name__ = fn.__name__
    wrap.__doc__ = fn.__doc__
    return wrap
</code></pre>
<pre><code>import time
@logger
def sleep(x):
    time.sleep(x)
</code></pre>
<pre><code>In[]:sleep.__name__
Out[]:'sleep'
</code></pre>
<p>其次也可以写一个函数</p>
<pre><code>def copy_properties(src,dst):
    dst.__name__ = src.__name__
    dst.__doc__ = src.__doc__
</code></pre>
<pre><code>import datetime

def logger(fn):
    def wrap(*args,**kwargs):
        start = datetime.datetime.now()
        ret = fn(*args,**kwargs)
        end = datetime.datetime.now()
        print('{} called took {}'.format(fn.__name__,end-start))
        return ret
    copy_properties(fn,wrap)
    return wrap
</code></pre>
<p>柯里化</p>
<pre><code>def copy_properties(src):
    def _copy(dst):
        dst.__name__ = src.__name__
        dst.__doc__ = src.__doc__
        return dst
    return _copy
</code></pre>
<p>copy_properties返回的是一个装饰器，可以这么来写</p>
<pre><code>import datetime

def logger(fn):
    @copy_properties(fn)
    def wrap(*args,**kwargs):
        start = datetime.datetime.now()
        ret = fn(*args,**kwargs)
        end = datetime.datetime.now()
        print('{} called took {}'.format(fn.__name__,end-start))
        return ret
    return wrap
</code></pre>
<p>再看下sleep.<strong>name</strong></p>
<pre><code>In[]:sleep.__name__
Out[]:'sleep'
</code></pre>
<p>functools</p>
<pre><code>help(functools.wraps)
Help on function wraps in module functools:

wraps(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))
    Decorator factory to apply update_wrapper() to a wrapper function
    
    Returns a decorator that invokes update_wrapper() with the decorated
    function as the wrapper argument and the arguments to wraps() as the
    remaining arguments. Default arguments are as for update_wrapper().
    This is a convenience function to simplify applying partial() to
    update_wrapper().
</code></pre>
<p>看看如何使用</p>
<pre><code>import datetime
import functools
def logger(fn):
    @functools.wraps(fn)
    def wrap(*args,**kwargs):
        start = datetime.datetime.now()
        ret = fn(*args,**kwargs)
        end = datetime.datetime.now()
        print('{} called took {}'.format(fn.__name__,end - start))
        return ret
    return wrap
</code></pre>
<pre><code>import time
@logger
def sleep(x):
    time.sleep(x)
</code></pre>
<pre><code>In[]:sleep(3)
Out[]:sleep called took 0:00:03.000353
</code></pre>
<p>这个就是copy_properties的由来<br>
柯里化其实是一个数学的概念，目的是让多个参数变成单个参数<br>
带参数的装饰器<br>
假如需要记录大于某个时间的操作，并且可以对这个时间做控制，通过参数传递进来</p>
<pre><code>import functools
import datetime
def logger(s):
    def _logger(fn):
        @functools.wraps(fn)
        def wrap(*args,**kwargs):
            start = datetime.datetime.now()
            ret = fn(*args,**kwargs)
            end = datetime.datetime.now()
            if (end - start).total_seconds() &gt; s:
                print('call {} took {}'.format(fn.__name__,end - start))
            return ret
        return wrap
    return _logger
</code></pre>
<p>(end - start).total_seconds()将时间格式的时间差转为数字格式</p>
<pre><code>import time
@logger(1)
def sleep(x):
    time.sleep(x)
</code></pre>
<p>执行时间大于1s的操作进行记录</p>
<pre><code>In[]:sleep(2)
Out[]:call sleep took 0:00:02
</code></pre>
<pre><code>In[]:sleep(1)
Out[]:
</code></pre>
<pre><code>In[]:sleep(3)
Out[]:call sleep took 0:00:03
</code></pre>
<p>sleep(2)和sleep(3)执行完后进行了记录，sleep(1)执行完没有进行记录<br>
@logger(1)拆开就是logger(1)(sleep)<br>
带参数的装饰器：一个函数，返回一个不带参数的装饰器<br>
多参数</p>
<pre><code>import functools
import datetime
def logger(s,p = lambda name,t : print('call {} took {} '.format(name,t))):
    def _logger(fn):
        @functools.wraps(fn)
        def wrap(*args,**kwargs):
            start = datetime.datetime.now()
            ret = fn(*args,**kwargs)
            end = datetime.datetime.now()
            if (end - start).total_seconds() &gt; s:
                p(fn.__name__,end - start)
            return ret
        return wrap
    return _logger
</code></pre>
<pre><code>import time
@logger(1)
def sleep(x):
    time.sleep(x)
</code></pre>
<pre><code>In[]：sleep(2)
Out[]：call sleep took 0:00:02 
</code></pre>
<pre><code>import time
@logger(1,p = lambda name,t : print('hahahaha'))
def sleep(x):
    time.sleep(x)
</code></pre>
<pre><code>In[]：sleep(2)
Out[]：hahahaha
</code></pre>
<p>超时后的打印逻辑可以进行自定义了<br>
作为装饰器，可以有多层，但是超过两层时首先要命名一个变量，然后再使用@变量()就可以了<br>
例如有logger _logger __logger三层时</p>
<pre><code>import functools
import datetime
def logger(s):
    def _logger(p = lambda name,t : print('call {} took {} '.format(name,t))):
        def __logger(fn):
            @functools.wraps(fn)
            def wrap(*args,**kwargs):
                start = datetime.datetime.now()
                ret = fn(*args,**kwargs)
                end = datetime.datetime.now()
                if (end - start).total_seconds() &gt; s:
                    p(fn.__name__,end - start)
                return ret
            return wrap
        return __logger
    return _logger
</code></pre>
<pre><code>import time
logger2s = logger(1)
@logger2s()
def sleep(x):
    time.sleep(x)
</code></pre>
<pre><code>In[]:sleep(3)
Out[]:call sleep took 0:00:03 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[装饰器]]></title>
        <id>https://yh0214.github.io/post/zhuang-shi-qi</id>
        <link href="https://yh0214.github.io/post/zhuang-shi-qi">
        </link>
        <updated>2019-10-10T05:48:00.000Z</updated>
        <content type="html"><![CDATA[<p>先来看一个函数，logger</p>
<pre><code>def logger(fn):
    def warp(*args,**kwargs):
        print('call {}'.format(fn.__name__))
        ret = fn(*args,**kwargs)
        print('{} called'.format(fn.__name__))
        return ret
    return warp
</code></pre>
<p>这个函数的参数是函数，返回值也是一个函数<br>
先定义一个加函数，作为参数传入logger</p>
<pre><code>def add(x,y):
    return x + y
</code></pre>
<p>然后定义一个函数</p>
<pre><code>In[]：
loged_add = logger(add)
loged_add(3,5)
Out[]：
call add
add called
8
</code></pre>
<p>loged_add = logger(add)这一步是把add函数作为参数传入logger中，这个时候没有发生任何计算，loged_add是一个函数，这个函数就是wrap<br>
可以查看下loged_add</p>
<pre><code>In[]：loged_add
Out[]：&lt;function __main__.logger.&lt;locals&gt;.warp(*args, **kwargs)&gt;
</code></pre>
<p>以上这种场景通常用于作为参数的函数执行前后需要一些额外操作<br>
再引入一个东西</p>
<pre><code>import datetime

def logger(fn):
    def wrap(*args,**kwargs):
        start = datetime.datetime.now()
        ret = fn(*args,**kwargs)
        end = datetime.datetime.now()
        print('{} called took {}'.format(fn.__name__,end-start))
        return ret
    return wrap
</code></pre>
<p>可以看看这个函数执行了多久</p>
<pre><code>import time

def sleep(x):
    time.sleep(x)
</code></pre>
<pre><code>In[]：loged_sleep = logger(sleep)
</code></pre>
<pre><code>In[]：loged_sleep(3)
Out[]：sleep called took 0:00:03
</code></pre>
<p>装饰器<br>
换一种语法糖</p>
<pre><code>@logger
def sleep(x):
    time.sleep(x)
</code></pre>
<p>这时候，就可以将封装发生在函数定义的时候<br>
这是python的一种语法，可以更方便的去定义我们的函数<br>
@logger的方式和loged_add = logger(add)是等效的<br>
参数是一个函数，返回值是一个函数的函数，就可以作为装饰器<br>
只有用@语法来写的时候，才称为装饰器。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高阶函数]]></title>
        <id>https://yh0214.github.io/post/gao-jie-han-shu</id>
        <link href="https://yh0214.github.io/post/gao-jie-han-shu">
        </link>
        <updated>2019-10-09T03:30:56.000Z</updated>
        <content type="html"><![CDATA[<p>首先看一个函数</p>
<pre><code>def counter(base):
    def inc(x=1):
        nonlocal base
        base += x
        return base
    return inc
</code></pre>
<pre><code>In[]：inc = counter(3)
In[]：inc(3)
Out[]：6
</code></pre>
<pre><code>In[]：inc(3)
Out[]：9
</code></pre>
<p>这种返回值是一个函数或者参数是函数的情况，就称为高阶函数<br>
第一种情况：返回值是函数<br>
第二种情况：参数是函数<br>
这两种情况的函数，就叫做高阶函数<br>
高阶函数的作用<br>
首先看一个排序函数，传入一个可迭代对象</p>
<pre><code>def sort(it):
    ret = []
    for x in it:
        for i,e in enumerate(ret):
            if x &gt; e:
                ret.insert(i,x)
                break
        else:
            ret.append(x)
    return ret
</code></pre>
<pre><code>In[]：sort([1,4,3,8,2,9,0,7])
Out[]：[9, 8, 7, 4, 3, 2, 1, 0]
</code></pre>
<p>如果要从小到大排列，只需要将大于改成小于就好了，x&lt;e<br>
一般要实现顺序排列和逆序排列需要两个函数，但是可以通过加一个判断，将两个功能通过一个函数实现</p>
<pre><code>def sort(it,r=False):
    ret = []
    for x in it:
        for i,e in enumerate(ret):
            if r:
                if x &lt; e:
                    ret.insert(i,x)
                    break
            else:
                if x &gt; e:
                    ret.insert(i,x)
                    break
        else:
            ret.append(x)
    return ret
</code></pre>
<p>还可以再次进行优化，将if判断抽出来，作为一个函数</p>
<pre><code>def sort(it,r=False):
    def cmp(a,b):
        if r:
            return a &lt; b
        else:
            return a &gt; b
    ret = []
    for x in it:
        for i,e in enumerate(ret):
            if cmp(x,e):
                ret.insert(i,x)
                break
        else:
            ret.append(x)
    return ret
</code></pre>
<p>那将cmp函数移到外面行不行呢？可以将cmp作为一个参数传入</p>
<pre><code>def sort(it,cmp=lambda a,b :a &lt; b):
    ret = []
    for x in it:
        for i,e in enumerate(ret):
            if cmp(x,e):
                ret.insert(i,x)
                break        
        else:
            ret.append(x)
    return ret
</code></pre>
<pre><code>In[]：sort([1,4,3,8,2,9,0,7],lambda a,b :a &gt; b)
Out[]：[9, 8, 7, 4, 3, 2, 1, 0]

</code></pre>
<pre><code>In[]：sort([1,4,3,8,2,9,0,7],lambda a,b :a &lt; b)
Out[]：[0, 1, 2, 3, 4, 7, 8, 9]
</code></pre>
<p>函数作为返回值：通常是用于闭包的场景，需要封装一些变量<br>
函数作为参数：通常是用于大多数逻辑固定，少部分逻辑不固定的场景</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生成器]]></title>
        <id>https://yh0214.github.io/post/sheng-cheng-qi</id>
        <link href="https://yh0214.github.io/post/sheng-cheng-qi">
        </link>
        <updated>2019-09-23T01:42:18.000Z</updated>
        <content type="html"><![CDATA[<p>生成器其实也是一个函数</p>
<pre><code>def g():
    for x in range(10):
        yield x
</code></pre>
<p>使用了一个新的关键字yield，没有return会不会报错？</p>
<pre><code>In[]：
r = g()
r
Out[]：&lt;generator object g at 0x000000000613E1B0&gt;
</code></pre>
<p>可以看到返回的是一个generator</p>
<pre><code>In[]：dir(r)
Out[]：
['__class__',
 '__del__',
 '__delattr__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__iter__',
 '__le__',
 '__lt__',
 '__name__',
 '__ne__',
 '__new__',
 '__next__',
 '__qualname__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 'close',
 'gi_code',
 'gi_frame',
 'gi_running',
 'gi_yieldfrom',
 'send',
 'throw']
</code></pre>
<p>它有'<strong>iter</strong>'方法，是一个可迭代对象<br>
它有'<strong>next</strong>'方法，是一个迭代<br>
使用next调用一下</p>
<pre><code>In[]：next(r)
Out[]：0
</code></pre>
<pre><code>In[]：next(r)
Out[]：1
</code></pre>
<p>返回的是函数中x的值<br>
有一个yield关键字，这个是一个迭代器，是迭代器里面的一个特殊内容，叫生成器<br>
执行完一次r = g()，现场应该被销毁了，但是r还是有值，还是可以继续调用next，事实上，函数的现场并没有被销毁，这就是生成器函数和普通函数不太一样的地方<br>
看下生成器是如何工作的</p>
<pre><code>def gen():
    print('a')
    yield 1
    print('b')
    yield 2
    return 3
</code></pre>
<p>定义了一个函数，有2个yield，1个return</p>
<pre><code>In[]：g = gen()
g
Out[]：&lt;generator object gen at 0x0000000003259570&gt;
</code></pre>
<p>理论上，gen里面有return，应该有返回值，但是这个g还是一个generator，说明函数并没有被执行<br>
接下来使用next调用</p>
<pre><code>In[]：next(g)
Out[]：
a
1
</code></pre>
<p>在这里，执行到第一个yield，就停止执行了<br>
再执行一次next(g)</p>
<pre><code>In[]：next(g)
Out[]：
b
2
</code></pre>
<p>打印出了b，然后到2就又停止了，而之前的a并没有被打印出来，说明现场保留了<br>
再执行一次next(g)</p>
<pre><code>In[]：next(g)
Out[]：
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
 in 
----&gt; 1 next(g)

StopIteration: 3
</code></pre>
<p>没有更多yield的时候，抛出StopIteration异常，还有一点需要注意的是，这个异常值就是它的返回值，没有返回值的话异常值就为空<br>
总结一下：带yield语句的函数称为生成器函数，生成器函数的返回值是生成器<br>
特点：</p>
<ul>
<li>生成器函数执行的时候，不会执行函数体（注意，这里是说生成器函数执行的时候，不是生成器执行的时候）</li>
<li>当next生成器的时候，当前代码会执行到之后的第一个yield，会弹出值，并暂停函数</li>
<li>当再次执行next生成器的时候，从上次暂停处开始往下执行</li>
<li>当没有多余的yield的时候，会抛出StopIteration异常，如果函数有返回值，异常的value是函数的返回值</li>
</ul>
<p>生成器是惰性求值的，先来写一个计数器</p>
<pre><code>def counter():
    x = 0
    while True:
        x += 1
        yield x

def inc(c):
    return next(c)
</code></pre>
<pre><code>In[]：c = counter()
In[]: inc(c)
Out[]：1
</code></pre>
<p>这样每次执行inc(c)都可以得到一个+1的值<br>
还可以封装的更好</p>
<pre><code>def inc():
    c = counter()
    return lambda : next(c)
</code></pre>
<p>还有一种更好的方法，可以把counter封装到inc里面</p>
<pre><code>def inc():
    def counter():
        x = 0
        while True:
            x += 1
            yield x
    c = counter()
    return lambda : next(c)
</code></pre>
<pre><code>In[]：incr = inc()
In[]: incr()
Out[]：1
</code></pre>
<pre><code>In[]：incr()
Out[]：2
</code></pre>
<p>难点</p>
<pre><code>def make_inc():
    def counter():
        x = 0
        while True:
            x += 1
            yield x
    c = counter()
    return next(c)
</code></pre>
<pre><code>In[]：make_inc()
Out[]：1
</code></pre>
<pre><code>In[]：make_inc()
Out[]：1
</code></pre>
<pre><code>In[]：make_inc()
Out[]：1
</code></pre>
<p>为什么再次执行还是得到1？<br>
每次都会初始化一个c，给它一个新的生成器，所以每次都是1<br>
使用lambda的话，只会生成一次c，后面每次都是调用这个函数<br>
应用<br>
斐波那契数列<br>
首先看使用递归实现，递归非常慢</p>
<pre><code>def fib(n):
    if n == 0:
        return 1
    if n == 1:
        return 1
    return fib(n-1) + fib(n-2)
</code></pre>
<p>还可以使用生成器实现</p>
<pre><code>def fib():
    a = 0
    b = 1
    while True:
        a,b = b,a + b
        yield a
</code></pre>
<pre><code>In[]：
f = fib()
for _ in range(5):
    print(next(f))
Out[]：
1
1
2
3
5
</code></pre>
<p>生成器可以解决递归问题<br>
协程是生成器的高级应用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[匿名函数]]></title>
        <id>https://yh0214.github.io/post/ni-ming-han-shu</id>
        <link href="https://yh0214.github.io/post/ni-ming-han-shu">
        </link>
        <updated>2019-09-19T14:45:17.000Z</updated>
        <content type="html"><![CDATA[<p>所谓匿名函数就是没有名字的函数，用lambda这个关键字来定义<br>
lambda后面接一个参数x，然后用冒号分隔，然后定义一个函数体</p>
<pre><code>lambda x : x + 1
</code></pre>
<p>冒号后面是不换行的</p>
<pre><code>In[]：(lambda x : x + 1)(3)
Out[]：4
</code></pre>
<pre><code>In[]：
f = lambda x : x + 1
f(3)
Out[]：4
</code></pre>
<p>匿名函数（lambda表达式）只能写在一行上，所以也被称为单行函数<br>
匿名函数可以不传参数，直接返回值</p>
<pre><code>In[]：
f = lambda : 0
f()
Out[]：0
</code></pre>
<p>匿名函数传递多个参数也是可以的</p>
<pre><code>In[]：
f = lambda x,y : x + y
f(3,5)
Out[]：8
</code></pre>
<p>匿名函数也是支持默认参数的</p>
<pre><code>In[]：
(lambda x,y=3:x + y)(3)
Out[]：6
</code></pre>
<p>匿名函数也是支持位置可变参数的</p>
<pre><code>In[]：
(lambda *args:args)(*range(3))
Out[]：(0, 1, 2)
</code></pre>
<p>关键字可变参数也是ok的</p>
<pre><code>In[]：
(lambda *args,**kwargs:print(args,kwargs))(*range(3),**{str(x):x for x in range(3)})
Out[]：(0, 1, 2) {'0': 0, '1': 1, '2': 2}
</code></pre>
<p>再来看下keyword-only参数</p>
<pre><code>In[]：
(lambda *,x : x)(x = 3)
Out[]：3
</code></pre>
<h1 id="匿名函数的应用">匿名函数的应用</h1>
<h2 id="sorted">sorted</h2>
<pre><code>In[]：
help(sorted)
Out[]：
Help on built-in function sorted in module builtins:
sorted(iterable, /, *, key=None, reverse=False)
    Return a new list containing all items from the iterable in ascending order.
    A custom key function can be supplied to customize the sort order, and the
    reverse flag can be set to request the result in descending order.
</code></pre>
<p>里面传一个可迭代对象，key默认是None，然后reverse代表反转<br>
假设有一个User对象，它有name和age两个属性</p>
<pre><code>from collections import namedtuple
User = namedtuple('User',['name','age'])
</code></pre>
<p>然后创建一个User的对象列表</p>
<pre><code>users = [User('yh',18),User('max',16),User('xxx',32)]
</code></pre>
<p>在不使用匿名函数的情况下，让users根据age来进行排序</p>
<pre><code>In[]：
def get_age(user):
    return user.age
sorted(users,key=get_age)
Out[]：
[User(name='max', age=16), User(name='yh', age=18), User(name='xxx', age=32)]
</code></pre>
<p>在使用匿名函数的情况下，让users根据age来进行排序</p>
<pre><code>In[]：sorted(users,key = lambda x : x.age)
Out[]：[User(name='max', age=16), User(name='yh', age=18), User(name='xxx', age=32)]
</code></pre>
<p>当函数作为参数时，需要使用匿名函数</p>
<h2 id="map">map</h2>
<pre><code>In[]：map(lambda x:x*2,[1,2,3])
Out[]：&lt;map at 0x64671d0&gt;
</code></pre>
<p>但是在python3中把map改成一个生成器了，可以使用list转换一下</p>
<pre><code>In[]：list(map(lambda x:x*2,[1,2,3]))
Out[]：[2, 4, 6]
</code></pre>
<h2 id="filter">Filter</h2>
<p>把每个可迭代对象传进来，如果函数返回True，就存在，返回False，就不存在</p>
<pre><code>In[]：list(filter(lambda x:x&lt;30,[16,18,32]))
Out[]：[16, 18]
</code></pre>
]]></content>
    </entry>
</feed>